<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on ゆーすけべー日記</title>
    <link>https://yusukebe.com/tags/golang/</link>
    <description>Recent content in Golang on ゆーすけべー日記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>© Copyright yusukebe.com</copyright>
    <lastBuildDate>Mon, 18 Jan 2016 11:18:00 +0900</lastBuildDate>
    
	<atom:link href="https://yusukebe.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golangを初めて本番投入したぜ！</title>
      <link>https://yusukebe.com/posts/2016/0118111838/</link>
      <pubDate>Mon, 18 Jan 2016 11:18:00 +0900</pubDate>
      
      <guid>https://yusukebe.com/posts/2016/0118111838/</guid>
      <description>先日「ボケて」サービス群の中でも「スタンプ」という機能を提供するアプリサーバがGo実装になりました。これが僕にとってほぼ初めての「Golang実戦投入」となります。Goの良さについては去年の10月に僕がやっているPodcast「wada.fm」でも言及していました。ただ、単純に良いからと言って、本番への導入となると既にユーザーを抱えているので、敷居が高いと感じます。そこで、工夫しつつ、じっくりと試して、現在に至りました。後述するようにハマりどころはありましたが、そのGoサーバは安定稼働していて、ユーザーへコンテンツを配信しています。そこで今回は新規にGoを導入する際の一つの事例として、今回、僕がやったボケてのスタンプサーバリプレースの経緯を紹介します。
LL言語への「若干の」不満 まず...
そもそもなんでGolangが必要なの？
 ってところ。ボケてのアプリケーションはほぼ全てが以前からPerlで書かれていて、キレイに本番で不具合も無く動いてくれていました。Plack/PSGIが登場してもはや久しく、アプリケーションサーバが安定し、またApp::cpanminus/Cartonといったモジュールインストーラやライブラリ管理も賢くやってくれます。ただ、これはLL全般に言えることなんですが、型が無いんですよね。
型がないってことは、サクッと書くときにはいいけど、堅牢にやりたい時に手間がかかります。 例えばPerlにはData::Validatorというライブラリがあるので、それを使ってメソッドへの引数のタイプチェックなどを追加で実装していました。例えばボケて内のlib/Bokete/Model/Boke.pmには以下のようなコードが記載されています。
sub create { state $rule = Data::Validator-&amp;gt;new( text =&amp;gt; &#39;Str&#39;, odai_id =&amp;gt; &#39;Str&#39;, user_id =&amp;gt; &#39;Str&#39;, category =&amp;gt; { isa =&amp;gt; &#39;Maybe[Str]&#39;, default =&amp;gt; undef }, tags =&amp;gt; { isa =&amp;gt; &#39;ArrayRef&#39;, default =&amp;gt; sub { [] } } )-&amp;gt;with(&#39;Method&#39;); my ($self, $args) = $rule-&amp;gt;validate(@_);  実装レベルでコードの中に出てくる「データ」もしくは「機能」それぞれに対して厳密にチェックしておきたい場合に、LLだと外部のライブラリを使う手間が生じたり、それが完璧に行われないケースがあるのです。逆に言えばそれがLLのいいところですが、使いドコロによってはより「strictに」やりたいアプリケーションもあるかと思うのです。
また、Perlは素晴らしく書きやすい言語だと思ってはいますが、他の違う言語も習得しておくと後々武器になって、楽しいんじゃないかなーって感じ、Goに手を出したという経緯になります。
Goの魅力 Golangを触ってみて良いなーって感じたことは前述した通り、wada.fmで話しております。興味のある方は聴いて下さい！
www.wada.fm
ただ簡単に列挙するならば...
 静的型付け言語だけどスクリプトっぽくかけてとっつきやすい  構造体にメソッド生やして「クラスのようなもの」を実現するとか「素朴」で良い コードを簡潔にするという方針などが現れた「ツンデレ」なコンパイラ  goroutine便利だし使いドコロが結構ある Webサーバで負荷テストした時にCPUリソースをキッチリ使いきってくれて消費メモリも既存アプリと比べて少ない 言語仕様的にもミニマムで「組み合わせでなんとかする」って点がPerlっぽい 優良なライブラリもどんどん出てる  などなど、でしょうかね。とにかく触ってみて、スッとコードを書き始めることが出来たのがよかったです。
Goをスクリプト的に利用する 実は今回紹介するスタンプサーバ以前にボケてではGoを使っていました。ただプロダクトとしていつも動くサーバやバッチ、という形では無く、書捨ての「スクリプトっぽい」コードを利用してたのです。
例えばRDBMSのとあるテーブルの構造を変えて、データ移行したい場合においてです。なんでGolangをそこで使うのか？というとgoroutineがあるからです。Goだとgoというキーワードだけで並行処理が走り、かつデータベース接続もロックせずよしなにやってくれるので、MySQLサーバの負荷の様子を見ながら並行数を調整することで「ある程度の負荷をかけながら」素早くデータ移行が出来て便利でした。以下のようにsync.WaitGroupでそのgoroutineで平行に走らせる処理数を調整しています。
for ;; { var results []Entry err = db.Select(&amp;amp;results, db.Where(&#34;column1&#34;.IsNull()), db.Limit(limit)); if err != nil { panic(err) } if len(results) == 0 { break } var wg sync.</description>
    </item>
    
  </channel>
</rss>