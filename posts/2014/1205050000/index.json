{
    "data" :  {
    "title": "フレームワーク使ってますか？",
    "date": "2014-12-05 05:00:00 +0900 JST",
    "dir": "posts/2014/",
    "slug": "1205050000",
    "categories": ["tech"],
    "tags": []
}

---



<p>昨日まで開催されていた「<strong>IVS CTO Night &amp; Day</strong>」でのとある一幕。100人もしくはそれに近い人数の、有名ドコロWebサービスなCTO達が集まる中、挙手制のこんな感じのアンケートがあった。</p>




<blockquote>
  <p>フレームワーク使ってますか？それとも独自？</p>
</blockquote>




<p>印象的だったのは<strong>「独自だぜ！」という人が割合としてかなり少なかった</strong>こと。その件について個人的な見解を書いてみます。ちなみにこちらは<a href="http://qiita.com/advent-calendar/2014/webapp_mook">Webアプリエンジニア養成読本 Advent Calendar 2014</a>の9日目の記事です。</p>




<hr>
<p>フレームワークと言っても色々な解釈の仕方があります。種別で言えば「Webアプリケーションフレームワーク」が一番に焦点が当たるところなんですが、それに内包される、もしくは、独立して<strong>「O/R Mapper」のようなフレームワークもあります</strong>。粒度やレイヤーで考えないといけない。なので、今回の質問に回答する場合、どこの層でフレームワークを使っているのか？オリジナルなのか？を定義しないと答えにくいかもしれません。ただこの件を追求するとエンドレスな議論になりそうなんで、一旦休止。</p>




<hr>
<p>僕の場合は「比較的」という意味合いで「独自だぜ！」の方に手を上げたのですが、Webアプリケーションフレームワークを使っているところもあれば、独自にWebアプリ層を組んでいるサービスもあります。また、今の自分が置かれている状況だと、開発者の人数が非常に少ないので、僕個人が使いやすいという判断で技術導入をしている理由で、フレームワークを利用するかどうかにこだわる必要はあんまないっす。会社の規模がある程度大きく、技術者がも多ければ、フレームワークを使うことでAPIを含め、共通のしきたりを素早く共有出来るでしょう。その場合、既存のフレームワークを使うのは効率的です。</p>




<hr>
<p>ここで、中間まとめ。つまりフレームワークを使うかどうかに関しては</p>




<ul>
<li>どのレイヤーについてのフレームワークかどうかを意識する</li>
<li>開発チームの規模によって判断基準が異なる</li>
<li>アプリケーションの性質によっても同様</li>
</ul>


<p>かと思います。また、初心者が学習すると言った目的の場合は一旦フレームワークを使ってみてその機能がどう挙動するか、感覚をつかむとう意味もありそうっすね。</p>




<hr>
<p>参考として、僕が今でやっている試みを紹介します。ちなみにバックエンドの言語は「Perl」を全面的に使っています。</p>




<p>当初はアプリケーションレベルでモデル層をWeb層から切り離す程度の施策をしていて、モデル単体のテスタビリティをあげつつ、Web以外のCommand Line Interface=CLIからの呼び出しにもモデルを利用可能にしていました。それ前提でWeb層では<code>Catalyst</code>や<code>Mojolicious</code>と言ったWebアプリケーションフレームワークを活かします。また、DB周りは特殊で、参照系は独自のライブラリ、更新系は<code>DBIx::Skinny</code>という非常に薄いO/R Mapperとも言えないほどのモジュールを使います。サービスの性質上、やはり<code>SELECT</code>が多いので、そこをオプティマイズする形です。結果として</p>




<ul>
<li>DBアクセス機能 / DBI＋α</li>
<li>クエリビルダー / SQL::Maker</li>
<li>inflateもしくはdeflate / 自分で書いたフィルター</li>
<li>アプリケーションでのキャッシュ / Cache::Memcached::Fast</li>
</ul>


<p>を組み合わせた一つのアプリ専用のライブラリが出来ました。これが「独自のライブラリ」ってやつです。ちょいとダーティなコードになっていますが、うまく機能しています。</p>




<p>それに加えて現在では、モバイルアプリも含めた各サービスごとにそれぞれHTTPをしゃべるWeb層をつくって個別にアクセスするのではなく、一つの、もしくは<code>Microservices</code>的に複数のAPIサーバのようなものを立ち上げ、フロントエンドが要望に応じてそれぞれから情報を取得したりポストする構成にしています。例えば、コアのロジックはJSONRPCをプロトコルとして、今まで書いたモデル層を生かして、サービスとして立ち上がっています。Webをつくるにしても、一度そこの<code>Method</code>を叩くような設計です。このアーキテクチャにより</p>




<ul>
<li>JSONRPCサーバの結合的なテストさえ通ればある程度品質は保証される</li>
<li>ロジックの出力がJSONで扱えるのでテストが容易</li>
<li>フロントエンドはモバイルも含め、どんな言語でも、どんなフレームワークでも実装してOK</li>
</ul>


<p>となります。今回のテーマである「フレームワークを使うべきか？」という視点で考えると、コアのロジックサーバは僕が<code>JSON::RPC</code>、<code>OAuth::Lite2</code>、<code>Router::Boom</code>、及び<code>Plack</code>で組んだアプリケーションになっていて、責任もって管理する。ちなみにこれらは単体ではフレームワークとは言えないにしろ、各種ライブラリを<strong>Perlらしくグルーとしてつなげたもの</strong>になっています。他のフロントに関しては実装する人によって、好きなフレームワークを使ってもいいですよ、という体制が組める。フレームワークを使った方が「素早く開発出来る」パートーナーがいた場合には有効でしょう。</p>




<hr>
<p>まぁこうやって振り返ると「フレームワークなんて使わず全部オレオレだぜ！」とも言えず、やはりハイブリッドにやっています。CTO Night &amp; Day の当日、はてなのCTOであるstanakaさんが話していた通り、何かあった時のために「中身を見て理解し、解決出来る」ようなフレームワークなどを選定するのも重要だと思いますし、先ほどまとめた通り、選定基準は千差万別です。ユーザーのことを意識してサービスを考えるように、サービスの開発に関わる内部についてもそれに関わる開発者や自分自身を意識して「今後」制作しやすいようにアーキテクチャを組むことが求められるのでしょうね。</p>



 
}
