+++
Categories = ["tech"]
Description = " 各種Model群についてObject::Containerを応用しつつ管理するとカジュアルにシングルトンになって効率いいかも！って思って、手元の小さなWebアプリで実装してみた。実験的にやってるんで、これおかしいって点あるかもなんでその場"
Tags = ["Perl", "Mojolicious"]
date = "2013-07-25T18:16:00+09:00"
title = "Object::Containerを応用したModel呼び出し"
author = "kamawada"
archive = ["2013"]
draft = false
+++


<p>各種Model群についてObject::Containerを応用しつつ管理するとカジュアルにシングルトンになって効率いいかも！って思って、手元の小さなWebアプリで実装してみた。実験的にやってるんで、これおかしいって点あるかもなんでその場合はお手柔らかにツッコんでくだされ。</p>

<p>だいたい僕はこんな感じでWebアプリのファイル、クラス構成をとっています。</p>

<pre> ./
└── MyApp
    ├── Model
    │   └── Entry.pm
    ├── Model.pm
    ├── Web
    │   └── Controller
    │       └── Root.pm
    └── Web.pm
 </pre>

<p>うんで、Controllerからはtokuhiromからよく「Catalystっぽいよねー」って言われているけど頑なに$self-&gt;model('Entry')のようなインターフェースでModelへアクセスしています。</p>

<pre> package MyApp::Web::Controller::Root;
use Mojo::Base 'Mojolicious::Controller';

sub index {
    my $self = shift;
    my $entries = $self-&gt;model('Entry')-&gt;get_recent_entries();
    $self-&gt;stash-&gt;{entries} = $entries;
    $self-&gt;render();
}

1;
 </pre>

<p>呼ばれるはずのMyApp::Model::Entryには呼び出されるはずのメソッドが定義されています。</p>

<pre> package MyApp::Model::Entry;
use Mouse;

sub get_recent_entries {
    ...;
    return $entries;
}

1;
 </pre>

<p>ここまでは個人的にいいとして、Modelをどのようにロードさせるかって話です。Object::Containerを使った今回の例ではまず、MyApp::Loader::Modelをつくりました。</p>

<pre> package MyApp::Loader::Model;
use Mouse;
use Module::Load qw//;

has 'instances' =&gt; ( is =&gt; 'rw', isa =&gt; 'HashRef[Object]', default =&gt; sub { +{} } );

sub load {
    my ($self, $name) = @_;
    my $instances = $self-&gt;instances;
    return $instances-&gt;{$name} if $instances-&gt;{$name};
    my $class = "MyApp::Model::" . String::CamelCase::camelize($name);
    Module::Load::load($class);
    my $model = $class-&gt;new;
    $instances-&gt;{$name} = $model;
    $self-&gt;instances($instances);
    return $class;
}

__PACKAGE__-&gt;meta-&gt;make_immutable();
 </pre>

<p>動的に名前で指定されたModelをロード。生成したModelのインスタンスをinstancesプロパティで保持しています。そしていよいよObject::Cotainerが登場します。このLoaderをシングルトンとして提供出来るようにします。</p>

<pre> package MyApp::Model;
use Object::Container '-base';
use MyApp::Loader::Model;

register 'model' =&gt; sub {
     return MyApp::Loader::Model-&gt;new;
};

1;
 </pre>

<p>なんか簡潔にするために他のコードを省いているんで無駄にクラス分けすぎ感ありますが... 最後にはMojoliciousなMyApp::Webでhelperの定義をします。</p>

<pre> package MyApp::Web;
use Mojo::Base 'Mojolicious';
use MyApp::Model;

sub startup {
    my $self = shift;
    $self-&gt;helper(
        model =&gt; sub {
            my ($c, $name) = @_;
            return MyApp::Model-&gt;get('model')-&gt;load($name);
        }
    );
...;
 </pre>

<p>するとControllerから$self-&gt;model('Entry')とかで二度目からはキャッシュされたModelインスタンスが取得出来ます。基本的にMyApp::ModelのgetメソッドからModelを取得することさえ守れば問題ないかな〜。と、まぁ<a href="http://yusukebe.com/archives/20130724/112022.html">昨日のエントリ</a>に引き続きWebアプリの構造と実装をどうするかを考える最近でございます。</p>

<p>＊ 追記</p>

<p>tokuhiromのご意見エントリー！</p>

<ul>
<li><a href="http://blog.64p.org/entry/2013/07/25/182336">Web アプリケーションのロジックを手続きとして実装する話</a></li>
</ul>


